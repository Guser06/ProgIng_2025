
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

int aleatorios(int mini, int maxi) {
    return mini + rand() % (maxi - mini + 1);
}

int mayormen(int *arre, int cant, int *mayor, int *menor) {
    if (cant <= 0) {
        printf("Error: Arreglo vacio para mayormen.\n");
        return 0;
    }
    *mayor = arre[0];
    *menor = arre[0];

    for (int i = 1; i < cant; i++) {
        if (arre[i] > *mayor) {
            *mayor = arre[i];
        }
        if (arre[i] < *menor) {
            *menor = arre[i];
        }
    }
    return 1;
}

int opcion1(int *cant, int *mini, int *maxi) {
    printf("Ingrese la cant. de num. aleatorios (entero): ");
    scanf("%d", cant);

    if (*cant <= 0) {
        printf("La cant. debe ser > 0.\n");
        return 0;
    }

    printf("Ingrese el val. min. (entero): ");
    scanf("%d", mini);
    printf("Ingrese el val. max. (entero): ");
    scanf("%d", maxi);

    if (*mini > *maxi) {
        printf("El val. min. no puede ser > al val. max.\n");
        return 0;
    }
    return 1;
}

int numeros(int *cant) {
    printf("Ingrese la cant. de num. a introducir (entero): ");
    scanf("%d", cant);

    if (*cant <= 0) {
        printf("La cant. debe ser > 0.\n");
        return 0;
    }
    return 1;
}

int ordenamiento(int *arre, int cant) {
    if (arre == NULL || cant <= 0) {
        return 0;
    }

    int i = 1;
    while (i < cant) {
        int x = arre[i];
        int j = i - 1;
        while (j >= 0 && arre[j] > x) {
            arre[j + 1] = arre[j];
            j = j - 1;
        }
        arre[j + 1] = x;
        i = i + 1;
    }
    return 1;
}

int* ImprimirA(int cant, int mini, int maxi) {
    int *nume = (int *)malloc(cant * sizeof(int));
    if (nume == NULL) {
        printf("Error: No se pudo asignar mem.\n");
        return NULL;
    }

    srand(time(NULL));

    printf("Numeros enteros generados:\n");
    for (int i = 0; i < cant; i++) {
        nume[i] = aleatorios(mini, maxi);
        printf("%d \n", nume[i]);
    }
    printf("\n");
    return nume;
}

int* opcion2(int cant) {
    int *nume = (int *)malloc(cant * sizeof(int));
    if (nume == NULL) {
        printf("Error: No se pudo asignar mem.\n");
        return NULL;
    }

    printf("Ingrese los %d numeros enteros:\n", cant);
    for (int i = 0; i < cant; i++) {
        printf("Numero %d: ", i + 1);
        scanf("%d", &nume[i]);
    }
    printf("\n");
    return nume;
}

int* historial(int *arre, int cant, int min, int max) {
    if (min > max) {
        printf("Error: El val. min. del hist. no puede ser > al val. max.\n");
        return NULL;
    }
    int tamano = max - min + 1;
    int *hist = (int *)calloc(tamano, sizeof(int));
    if (hist == NULL) {
        return NULL;
    }
    for (int i = 0; i < cant; i++) {
        int intervalo = arre[i];
        if (intervalo >= min && intervalo <= max) {
            int indice = intervalo - min;
            hist[indice]++;
        }
    }
    return hist;
}

float mediaa(int *arre, int cant){
    float media = 0;
    if (cant == 0) return 0.0f;
    for (int i = 0; i < cant; i++) {
        media += arre[i];
    }
    media = media / cant;
    return media;
}

float mediana(int *arre, int cant){
    float mediana = 0;
    if (cant == 0) return 0.0f;

    if (cant % 2 == 0){
        mediana = (float)(arre[cant / 2 - 1] + arre[cant / 2]) / 2.0f;
    }else{
        mediana = (float)arre[cant / 2];
    }
    return mediana;
}

float numerador(int *arre, int cant, float media){
    float sum_sq_diff = 0.0f;
    if (cant == 0) return 0.0f;
    for (int i = 0; i < cant; i++){
        float diff = arre[i] - media;
        sum_sq_diff += diff * diff;
    }
    return sum_sq_diff;
}

float mediag(int *arre, int cant){
    if (cant == 0) return 0.0f;
    double producto = 1.0;

    for (int i = 0; i < cant; i++) {
        if (arre[i] <= 0) {
            printf("Advertencia: No se puede calcular media geometrica con numeros no positivos. \n");
            return 0.0f;
        }
        producto *= (double)arre[i];
    }
    return (float)pow(producto, 1.0 / cant);
}

float moda(int *hist, int min, int max){
    if (hist == NULL || (max - min + 1) <= 0) return 0.0f;

    int max_f = 0;
    int moda_val = min;

    for (int i = 0; i <= (max - min); i++) {
        if (hist[i] > max_f) {
            max_f = hist[i];
            moda_val = min + i;
        }
    }
    return (float)moda_val;
}

float obtener_cuantil(int *arre, int cant, int i, int divisor) {
    if (arre == NULL || cant <= 0 || i <= 0 || i > divisor) {
        return 0.0f;
    }

    double posicion = (double)i * cant / divisor;

    int indice_1_base = (int)ceil(posicion);

    int indice_0_base = indice_1_base - 1;

    if (indice_0_base < 0) indice_0_base = 0;
    if (indice_0_base >= cant) indice_0_base = cant - 1;

    return (float)arre[indice_0_base];
}

void imprimir_cuantiles(int *arre, int cant) {
    if (cant <= 0) {
        printf("\nNo se pueden calcular cuantiles para un arreglo vacío.\n");
        return;
    }

    printf("\n--- Cuartiles ---\n");
    printf("Cuartil 1 (Q1): %.2f\n", obtener_cuantil(arre, cant, 1, 4));
    printf("Cuartil 2 (Q2 - Mediana): %.2f\n", mediana(arre, cant));
    printf("Cuartil 3 (Q3): %.2f\n", obtener_cuantil(arre, cant, 3, 4));

    printf("\n--- Deciles ---\n");
    for (int i = 2; i <= 10; i += 2) {
        if (i == 5) {
            printf("Decil %d (D%d - Mediana): %.2f\n", i, i, mediana(arre, cant));
        } else {
            printf("Decil %d (D%d): %.2f\n", i, i, obtener_cuantil(arre, cant, i, 10));
        }
    }

    printf("\n--- Percentiles ---\n");
    for (int i = 10; i <= 100; i += 10) {
        if (i == 50) {
            printf("Percentil %d (P%d - Mediana): %.2f\n", i, i, mediana(arre, cant));
        } else {
            printf("Percentil %d (P%d): %.2f\n", i, i, obtener_cuantil(arre, cant, i, 100));
        }
    }
}

void momento(int *arre, int cant, float varianza_muestral){
    if (cant <= 0) {
        printf("No se pueden calcular momentos para un arreglo vacio.\n");
        return;
    }

    double m[4] = {0.0};

    for (int i = 0; i < cant; i++) {
        double valor_actual = (double)arre[i];
        m[0] += valor_actual;
        m[1] += pow(valor_actual, 2);
        m[2] += pow(valor_actual, 3);
        m[3] += pow(valor_actual, 4);
    }

    double a[4];
    a[0] = m[0] / cant;
    a[1] = m[1] / cant;
    a[2] = m[2] / cant;
    a[3] = m[3] / cant;

    printf("\n--- Momentos (respecto al origen) ---\n");
    printf("Momento 0: %.2f\n", 1.0);
    printf("Momento 1: %.2f\n", a[0]);
    printf("Momento 2: %.2f\n", a[1]);
    printf("Momento 3: %.2f\n", a[2]);
    printf("Momento 4: %.2f\n", a[3]);

    double c[5];

    c[0] = 1.0;
    c[1] = 0.0;
    c[2] = varianza_muestral;
    c[3] = a[2] - (3 * a[0] * a[1]) + (2 * pow(a[0], 3));
    c[4] = a[3] - (4 * a[0] * a[2]) + (6 * pow(a[0], 2) * a[1]) - (3 * pow(a[0], 4));
    printf("\n--- Momentos Centrales (respecto a la media) ---\n");
    for (int i = 0; i <= 4; i++) {
        printf("Momento %d: %.2f\n", i, c[i]);
    }
}


int resumen(int re_may, int re_men, int *hist, int mini_hist, int maxi_hist, int cant, int *arre) {
    printf("\n");
    printf("--- Resumen ---\n");
    printf("Numeros ordenados:\n");
    for (int i = 0; i < cant; i++) {
        printf("%d \n", arre[i]);
    }
    printf("\nEl número mayor: %d\n", re_may);
    printf("El número menor: %d\n", re_men);

    float media_calculada = mediaa(arre, cant);

    printf("Media: %.2f\n", media_calculada);
    printf("Mediana: %.2f\n", mediana(arre, cant));
    printf("Media Geom.: %.2f\n", mediag(arre, cant));
    printf("Moda: %.2f\n", moda(hist, mini_hist, maxi_hist));

    float varianza = 0.0f;
    if (cant > 1) {
        float suma_diferencias = numerador(arre, cant, media_calculada);
        varianza = suma_diferencias / cant;
    }
    printf("Varianza: %.2f\n", varianza);
    printf("Desviacion estandar: %.2f\n", sqrt(varianza));

    imprimir_cuantiles(arre, cant);

    momento(arre, cant,varianza);

    if (hist != NULL) {
        printf("\n--- Histograma (partes enteras) ---\n");
        for (int i = 0; i <= (maxi_hist - mini_hist); i++) {
            if (hist[i] > 0) {
                printf("h(%d): %d\n", mini_hist + i, hist[i]);
            }
        }
        return 1;
    } else {
        printf("\nNo se pudo generar el histograma.\n");
        return 0;
    }
}

int main() {
    int   opci;
    int   cant;
    int   mini, maxi;
    int   re_may, re_men;
    int   *arr_num = NULL;
    int   *hist_res = NULL;
    int   mini_hist = 0;
    int   maxi_hist = 0;

    printf("Elija una opcion:\n");
    printf("1. Numeros aleatorios\n");
    printf("2. Introducir numeros manualmente\n");
    printf("Opcion: ");
    scanf("%d", &opci);
    printf("\n");

    if (opci == 1) {
        if (!opcion1(&cant, &mini, &maxi)) {
            return 1;
        }
        printf("\n");
        arr_num = ImprimirA(cant, mini, maxi);
    } else if (opci == 2) {
        if (!numeros(&cant)) {
            return 1;
        }
        printf("\n");
        arr_num = opcion2(cant);
    } else {
        printf("Opcion invalida.\n");
        return 1;
    }

    if (arr_num == NULL) {
        return 1;
    }

    if (cant <= 0) {
        printf("Error: Cantidad de numeros invalida para procesar.\n");
        free(arr_num);
        return 1;
    }

    if (!mayormen(arr_num, cant, &re_may, &re_men)) {
        printf("Error al calcular mayor y menor.\n");
        free(arr_num);
        return 1;
    }

    if (!ordenamiento(arr_num, cant)) {
        printf("Error al ordenar el arreglo.\n");
        free(arr_num);
        return 1;
    }

    mini_hist = re_men;
    maxi_hist = re_may;

    if (mini_hist > maxi_hist) {
        maxi_hist = mini_hist;
    }

    hist_res = historial(arr_num, cant, mini_hist, maxi_hist);

    resumen(re_may, re_men, hist_res, mini_hist, maxi_hist, cant, arr_num);

    free(arr_num);
    if (hist_res != NULL) {
        free(hist_res);
    }

    return 0;
}